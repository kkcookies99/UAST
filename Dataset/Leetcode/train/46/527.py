 class Solution(object):
    def XXX(self, nums):
        """
        [1,2,3]全排列可以看成
        [1]+[2,3]的全排列---->[1,2]+[3]的全排列，[1,3]+[2]的全排列--->[1,2,3],[1,3,2]
        [2]+[1,3]的全排列---->[2,1]+[3]的全排列，[2,3]+[1]的全排列--->[2,1,3],[2,3,1]
        [3]+[1,2]的全排列---->[3,1]+[2]的全排列，[3,2]+[1]的全排列--->[3,1,2],[3,2,1]
        [2,3]一样可以看成----->[2]+[3]的全排列,[3]+[2]的全排列--->[2,3],[2,3]
        全排列可以分解为：[循环当前序列的某个数]+在此之前的序列+除开这个数的序列的全排列。
        只需要设置递归的边界条件：即当前处理序列只有一个数时，无法再进行递归。
        就直接将该（[x]）序列与前置序列合并加入到输出序列中。
        每次遇到边界就完成了全排列中其中一个排列。
        """
        res_list=[]#存放结果的列表
        def dfs(l_num,Nums):#l_num记录之前得到的排列顺序数，Nums为当前处理数组
            for i in range(len(Nums)):
                if len(Nums)==1: #递归的边界条件
                    res_list.append(l_num+Nums)#将前置序列与这个数合并，加入到输出序列中
                    return
                else:
                    #dfs（[循环当前序列的某个数]+在此之前的序列，除开这个数的序列）
                    dfs(l_num+[Nums[i]],Nums[0:i]+Nums[i+1:])#
        dfs([],nums)
        return res_list

                

